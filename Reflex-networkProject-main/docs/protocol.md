# پروتکل Reflex

قبل از اینکه کد بزنی، بذار ببینیم Reflex چیه و چرا طراحی شده. اگه می‌خوای فقط شروع کنی، برو سراغ [Step 1](step1-basic.md). ولی اگه می‌خوای بفهمی چرا اینطوری طراحی شده، همینجا بمون.

## چرا پروتکل‌های قبلی شکست خوردن؟

### VMess: وقتی همه چیز در یک بسته بود

VMess یه پروتکل stateful بود که همه چیز رو توی خودش داشت: رمزنگاری، احراز هویت، همه چیز. مشکل اینجا بود که:

**وابستگی به زمان سیستم**: VMess از timestamp برای احراز هویت استفاده می‌کرد. اگه ساعت کلاینت و سرور sync نبودن، handshake fail می‌شد. این خودش یه fingerprint بود - یه ناظر می‌تونست ببینه که ترافیک وابسته به زمان هست و حدس بزنه که VMess هست.

**رمزنگاری سفارشی**: VMess یه رمزنگاری AEAD سفارشی داشت که الگوهای قابل تشخیصی ایجاد می‌کرد. وقتی DPI پیشرفته شد، این الگوها رو شناسایی کردن و VMess رو block کردن.

**راه‌حل‌های موقت**: بعدها VMess+TLS+WebSocket اومد که یه لایه اضافی پنهان‌سازی بود. کار می‌کرد، ولی overhead زیادی داشت و پیچیده بود.

### VLESS: ساده‌تر، ولی یه مشکل بزرگ

VLESS stateless بود و خیلی سریع‌تر از VMess. ایده اصلی این بود که رمزنگاری رو به TLS واگذار کنه و خودش فقط routing کنه. ولی یه مشکل داشت که خیلی بزرگ بود:

**TLS-in-TLS**: وقتی ترافیک HTTPS از VLESS+TLS عبور می‌کرد، یه handshake TLS کامل داخل یه جریان از قبل رمزنگاری‌شده رخ می‌داد. این الگو خیلی غیرعادی بود و به راحتی قابل شناسایی بود. یه ناظر می‌تونست ببینه که:
1. اول یه TLS handshake (برای VLESS)
2. بعد داخلش یه TLS handshake دیگه (برای HTTPS واقعی)

این "nested TLS" یه fingerprint قدرتمند بود که مستقل از محتوای پروتکل بود. XTLS و REALITY سعی کردن این مشکل رو حل کنن، ولی مشکل بنیادی همچنان باقی بود.

### Trojan: وقتی انکارپذیری مهم‌تر از رمزنگاری بود

Trojan یه تغییر پارادایم بود. به جای اینکه سعی کنه پروتکل رو غیرقابل شناسایی کنه، سعی کرد رفتار سرور رو غیرقابل تشخیص کنه.

**مکانیزم Fallback**: اگه کسی با پروتکل درست متصل نمی‌شد (مثلاً یه active probe یا یه مرورگر عادی)، سرور ترافیک رو به یه وب‌سرور واقعی می‌فرستاد. از دید ناظر، سرور دقیقاً مثل یه وب‌سرور HTTPS عادی رفتار می‌کرد.

**مقاومت در برابر Active Probing**: وقتی یه سانسورچی می‌خواست سرور رو تست کنه، به جای خطای پروتکل، یه صفحه وب عادی می‌دید. این هزینه شناسایی رو خیلی بالا می‌برد.

درس مهم: مقاومت در برابر کاوش فعال (active probing) یه نیاز اساسی برای پروتکل‌های نسل بعدی بود.

## Reflex: ترکیب بهترین‌ها

Reflex سعی می‌کنه بهترین ایده‌های VMess، VLESS و Trojan رو بگیره و مشکلاتشون رو حل کنه:

### هندشیک ضمنی (Implicit Handshake)

به جای یه handshake واضح مثل TLS که همه می‌شناسن، Reflex تبادل کلید رو داخل بسته‌های اولیه که شبیه ترافیک عادی هستن پنهان می‌کنه. کلاینت یه بسته می‌فرسته که شبیه HTTP POST هست، سرور جواب می‌ده که شبیه HTTP 200 هست. ولی زیر پوستش، کلیدها مبادله می‌شن و احراز هویت انجام می‌شه.

این یعنی از اول، ترافیک شبیه یه API call عادی به نظر می‌رسه، نه یه پروتکل پراکسی.

### Fallback مثل Trojan

اگه کسی با پروتکل درست متصل نشد (مثلاً یه active probe یا مرورگر عادی)، ترافیک به یه وب‌سرور واقعی فرستاده می‌شه. این مقاومت در برابر کاوش فعال رو فراهم می‌کنه.

### بدون TLS-in-TLS

چون هندشیک صریح نداره، مشکل TLS-in-TLS رو نداره. اگه بخوای از TLS استفاده کنی (مثلاً برای ECH)، می‌تونی، ولی اجباری نیست. Reflex می‌تونه روی vanilla TCP هم کار کنه.

## جریان کار

```
کلاینت                    سرور
  |                         |
  |-- بسته اول (شبیه HTTP POST) -->|
  |   [کلید عمومی + UUID + Policy] |
  |                         | (بررسی می‌کنه)
  |                         | (تبادل کلید انجام می‌شه)
  |<-- پاسخ (شبیه HTTP 200) --|
  |   [کلید عمومی سرور + Policy Grant] |
  |                         |
  | (کلید جلسه استخراج شده) |
  |                         |
  |<========== Frame‌های رمزنگاری شده ==========>|
```

بذار ببینیم زیر پوستش چی داره می‌شه:

1. **کلاینت** یه بسته می‌فرسته که شبیه HTTP POST هست. داخلش کلید عمومی X25519، UUID کاربر، و درخواست سیاست (policy request) هست که با pre-shared key رمزنگاری شده.

2. **سرور** بسته رو می‌خونه، کلید مشترک رو محاسبه می‌کنه، کاربر رو با UUID احراز هویت می‌کنه، و جواب می‌ده که شبیه HTTP 200 هست. داخلش کلید عمومی سرور و policy grant هست.

3. **هر دو طرف** کلید جلسه رو از کلید مشترک استخراج می‌کنن (با HKDF).

4. **بعد از handshake**، همه داده‌ها در Frame‌های رمزنگاری شده با ChaCha20-Poly1305 ارسال می‌شن.

## ساختار Frame

بعد از handshake، همه داده‌ها در Frame‌ها ارسال می‌شن. هر Frame یه header کوچیک داره:

```
[طول (2 بایت)] [نوع (1 بایت)] [داده‌های رمزنگاری شده]
```

- **طول**: اندازه payload رمزنگاری شده (2 بایت، big-endian)
- **نوع**: نوع Frame (1 بایت):
  - `0x01`: FrameTypeData (DATA) - داده‌های واقعی کاربر
  - `0x02`: FrameTypePadding (PADDING_CTRL) - دستور padding
  - `0x03`: FrameTypeTiming (TIMING_CTRL) - دستور timing
  - `0x04`: FrameTypeClose (CLOSE) - بستن اتصال
- **داده**: payload رمزنگاری شده با ChaCha20-Poly1305

هر Frame با یه nonce منحصر به فرد رمزنگاری می‌شه که از یه counter استفاده می‌کنه (یکی برای read، یکی برای write).

## چرا این طراحی بهتره؟

**غیرقابل تشخیص از اول**: از اولین بایت، ترافیک شبیه یه API call عادی به نظر می‌رسه. می‌تونی از HTTP POST-like استفاده کنی (پنهان‌کارتر) یا magic number (سریع‌تر). هیچ handshake واضحی نیست که نشون بده این یه پروتکل پراکسی هست.

**مقاوم در برابر کاوش**: اگه کسی تست کنه، به وب‌سرور عادی وصل می‌شه و یه صفحه وب می‌بینه. هیچ خطای پروتکلی نیست که نشون بده این یه سرور پراکسی هست.

**بدون اثر انگشت TLS**: مشکل TLS-in-TLS رو نداره چون هندشیک صریح نداره. اگه بخوای از TLS استفاده کنی (مثلاً برای ECH)، می‌تونی، ولی اجباری نیست.

**Traffic Morphing بومی**: می‌تونی ترافیک رو طوری شکل بدی که شبیه یه پروتکل بی‌خطر باشه (مثلاً YouTube یا Zoom). این یه feature درجه یک پروتکله، نه یه addon.

## چرا VLESS flow نمی‌تواند؟

یه سوال رایجه: چرا نمی‌شه همین قابلیت‌ها رو با VLESS + flow + config اضافه کرد؟ بذار ببینیم:

### مشکل 1: Handshake صریح
VLESS همیشه یه handshake واضح داره (حتی اگه flow اضافه کنی). این handshake از اولین بایت قابل شناساییه. Reflex handshake رو داخل بسته‌های عادی پنهان می‌کنه - از دید ناظر، ترافیک شبیه HTTP POST عادی به نظر می‌رسه.

### مشکل 2: Traffic Morphing دوطرفه
VLESS flow فقط یک طرفه کار می‌کنه (مثلاً فقط upload یا download). Reflex با Frame‌های `PADDING_CTRL` و `TIMING_CTRL` می‌تونه morphing رو دوطرفه کنه - هم کلاینت و هم سرور می‌تونن به هم بگن که چطوری ترافیک رو شکل بدن. این یعنی:
- کلاینت می‌تونه به سرور بگه: "یه بسته 1400 بایتی با تأخیر 10ms بفرست"
- سرور می‌تونه به کلاینت بگه: "بسته بعدی رو 500 بایت کن و 30ms تأخیر بده"

این هماهنگی دوطرفه با VLESS flow ممکن نیست.

### مشکل 3: Fallback ترکیبی
VLESS می‌تونه fallback داشته باشه، ولی تشخیص پروتکل با `Peek` خیلی ساده‌تره وقتی handshake صریح نیست. Reflex می‌تونه هم magic number رو چک کنه (سریع) هم HTTP POST-like رو parse کنه (پنهان‌کار). این ترکیب با VLESS ممکن نیست چون handshake همیشه واضحه.

### مشکل 4: بدون TLS-in-TLS
VLESS+TLS همیشه مشکل TLS-in-TLS رو داره. Reflex می‌تونه روی vanilla TCP کار کنه و اگه بخوای TLS اضافه کنی (مثلاً برای ECH)، می‌تونی، ولی اجباری نیست. این یعنی از اول مشکل TLS-in-TLS رو نداره.

### خلاصه
VLESS flow یه addon خوبه، ولی نمی‌تونه این قابلیت‌ها رو داشته باشه:
- Handshake ضمنی (پنهان در ترافیک عادی)
- Morphing دوطرفه با کنترل دقیق
- تشخیص ترکیبی (magic + HTTP POST)
- بدون TLS-in-TLS از اول

Reflex این قابلیت‌ها رو از اول در طراحی داره، نه به عنوان addon.

---

حالا که فهمیدید پروتکل چطوری کار می‌کنه و چرا با VLESS flow متفاوته، برید سراغ [Step 1](step1-basic.md) و شروع به پیاده‌سازی کنید.

